/*
ChannelEngine Merchant API

ChannelEngine API for merchants

API version: 2.14.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package merchant

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ProductAPIService ProductAPI service
type ProductAPIService service

type ProductAPIProductBulkDeleteRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	requestBody *[]string
}

// The list of MerchantProductNo of the products you wish to delete.
func (r ProductAPIProductBulkDeleteRequest) RequestBody(requestBody []string) ProductAPIProductBulkDeleteRequest {
	r.requestBody = &requestBody
	return r
}

func (r ProductAPIProductBulkDeleteRequest) Execute() (*ApiResponse, *http.Response, error) {
	return r.ApiService.ProductBulkDeleteExecute(r)
}

/*
ProductBulkDelete Deletes products

Deletes a products based on the **Merchant product number**.<br /> <br />**NB:** ChannelEngine deactivates but does not delete the products entirely, as they might be still referenced in orders.<br />Therefore, the references used for these products cannot be reused.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProductAPIProductBulkDeleteRequest
*/
func (a *ProductAPIService) ProductBulkDelete(ctx context.Context) ProductAPIProductBulkDeleteRequest {
	return ProductAPIProductBulkDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ApiResponse
func (a *ProductAPIService) ProductBulkDeleteExecute(r ProductAPIProductBulkDeleteRequest) (*ApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductBulkDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/products/bulkdelete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIProductBulkPatchRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	patchMerchantProductDto *PatchMerchantProductDto
}

// 1) PropertiesToUpdate: Fields to update&lt;br /&gt;2) MerchantProductRequestModels: Products to be updated
func (r ProductAPIProductBulkPatchRequest) PatchMerchantProductDto(patchMerchantProductDto PatchMerchantProductDto) ProductAPIProductBulkPatchRequest {
	r.patchMerchantProductDto = &patchMerchantProductDto
	return r
}

func (r ProductAPIProductBulkPatchRequest) Execute() (*SingleOfProductCreationResult, *http.Response, error) {
	return r.ApiService.ProductBulkPatchExecute(r)
}

/*
ProductBulkPatch Updates products attributes

Updates specific attributes of product data. You can update single or multiple attributes for one or multiple products.<br />You can also add custom attributes via this endpoint. The format of this endpoint is JSON Patch.<br />Products are updated for the fields listed in the array **PropertiesToUpdate**:<br />[name, <br />description, <br />details, <br />brand, <br />size, <br />color, <br />ean, <br />groupno **or** ParentMerchantProductNo, <br />groupno2 **or** ParentMerchantProductNo2, <br />type, <br />merchantproductno,<br />vendorproductno, <br />stock, <br />price, <br />listprice **or** MSRP, <br />purchaseprice, <br />minprice, <br />maxprice, <br />discountrate, <br />vatrate, <br />margin, <br />shippingcost, <br />shippingtime, <br />url, <br />imageurl, <br />extraimageurl1, <br />extraimageurl2, <br />extraimageurl3, <br />extraimageurl4, <br />extraimageurl5, <br />extraimageurl6, <br />extraimageurl7, <br />extraimageurl8, <br />extraimageurl9, <br />categoryid,<br />vatratetype]<br /> <br />Sample request:<br /><pre><br />PATCH /v2/products<br />{<br /> "PropertiesToUpdate": [<br /> "name",<br /> "description"<br /> ],<br /> "MerchantProductRequestModels": [<br /> {<br /> "MerchantProductNo": "testMerchantProductNo",<br /> "Name": "testName",<br /> "Description": "testDescription",<br /> },<br /> {<br /> "MerchantProductNo": "testMerchantProductNo2",<br /> "Name": "testName3",<br /> "Description": "testDescription1",<br /> }<br /> ]<br />}<br /></pre>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProductAPIProductBulkPatchRequest
*/
func (a *ProductAPIService) ProductBulkPatch(ctx context.Context) ProductAPIProductBulkPatchRequest {
	return ProductAPIProductBulkPatchRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SingleOfProductCreationResult
func (a *ProductAPIService) ProductBulkPatchExecute(r ProductAPIProductBulkPatchRequest) (*SingleOfProductCreationResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SingleOfProductCreationResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductBulkPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/products"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchMerchantProductDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIProductBulkPatchExtraDataItemsRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	merchantProductExtraDataRequest *[]MerchantProductExtraDataRequest
}

func (r ProductAPIProductBulkPatchExtraDataItemsRequest) MerchantProductExtraDataRequest(merchantProductExtraDataRequest []MerchantProductExtraDataRequest) ProductAPIProductBulkPatchExtraDataItemsRequest {
	r.merchantProductExtraDataRequest = &merchantProductExtraDataRequest
	return r
}

func (r ProductAPIProductBulkPatchExtraDataItemsRequest) Execute() (*SingleOfProductCreationResult, *http.Response, error) {
	return r.ApiService.ProductBulkPatchExtraDataItemsExecute(r)
}

/*
ProductBulkPatchExtraDataItems Adds, updates, or deletes custom attributes

Adds, updates, or deletes the custom attributes (a.k.a. extra data keys) for multiple products.<br />You can update single or multiple attributes for one or multiple products. The format of this endpoint is [JSON Patch](http://jsonpatch.com/).<br /><br />**NB:** the **Merchant product number** must be unique.<br /><br />Sample request:<br /><pre><br />PATCH /v2/products/extra-data/bulk<br />[<br /> {<br /> "MerchantProductNo": "{merchantProductNo}",<br /> "Operations": [<br /> {<br /> "Op": "add",<br /> "Key": "{Key}",<br /> "Value": "{Value}"<br /> }<br /> ]<br /> },<br /> {<br /> "MerchantProductNo": "{merchantProductNo}",<br /> "Operations": [<br /> {<br /> "Op": "replace",<br /> "Key": "{Key}",<br /> "Value": "{Value}"<br /> },<br /> {<br /> "Op": "add",<br /> "Key": "{Key}",<br /> "Value": "{Value}"<br /> }<br /> ]<br /> },<br /> {<br /> "MerchantProductNo": "{merchantProductNo}",<br /> "Operations": [<br /> {<br /> "Op": "remove",<br /> "Key": "{Key}",<br /> "Value": "{Value}"<br /> }<br /> ]<br /> }<br /> ]<br /></pre>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProductAPIProductBulkPatchExtraDataItemsRequest
*/
func (a *ProductAPIService) ProductBulkPatchExtraDataItems(ctx context.Context) ProductAPIProductBulkPatchExtraDataItemsRequest {
	return ProductAPIProductBulkPatchExtraDataItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SingleOfProductCreationResult
func (a *ProductAPIService) ProductBulkPatchExtraDataItemsExecute(r ProductAPIProductBulkPatchExtraDataItemsRequest) (*SingleOfProductCreationResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SingleOfProductCreationResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductBulkPatchExtraDataItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/products/extra-data/bulk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.merchantProductExtraDataRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIProductCreateRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	merchantProductRequest *[]MerchantProductRequest
	ignoreStock *bool
	ignorePrice *bool
}

func (r ProductAPIProductCreateRequest) MerchantProductRequest(merchantProductRequest []MerchantProductRequest) ProductAPIProductCreateRequest {
	r.merchantProductRequest = &merchantProductRequest
	return r
}

func (r ProductAPIProductCreateRequest) IgnoreStock(ignoreStock bool) ProductAPIProductCreateRequest {
	r.ignoreStock = &ignoreStock
	return r
}

func (r ProductAPIProductCreateRequest) IgnorePrice(ignorePrice bool) ProductAPIProductCreateRequest {
	r.ignorePrice = &ignorePrice
	return r
}

func (r ProductAPIProductCreateRequest) Execute() (*SingleOfProductCreationResult, *http.Response, error) {
	return r.ApiService.ProductCreateExecute(r)
}

/*
ProductCreate Updates or creates products

Updates or creates products. The endpoint is purge and replace.<br />If you do not include an attribute, it is overwritten with null.<br />Extra data arrays are not effected by purge and replace, and remain unchanged.<br />To exclude stock from the update, set the **Ignore stock** attribute to **true**.<br />To exclude price from the update, set the **Ignore price** attribute to **true**.<br /><br />**NB:** the **Merchant product number** must be unique.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProductAPIProductCreateRequest
*/
func (a *ProductAPIService) ProductCreate(ctx context.Context) ProductAPIProductCreateRequest {
	return ProductAPIProductCreateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SingleOfProductCreationResult
func (a *ProductAPIService) ProductCreateExecute(r ProductAPIProductCreateRequest) (*SingleOfProductCreationResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SingleOfProductCreationResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/products"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.merchantProductRequest == nil {
		return localVarReturnValue, nil, reportError("merchantProductRequest is required and must be specified")
	}

	if r.ignoreStock != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignoreStock", r.ignoreStock, "")
	} else {
		var defaultValue bool = false
		r.ignoreStock = &defaultValue
	}
	if r.ignorePrice != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ignorePrice", r.ignorePrice, "")
	} else {
		var defaultValue bool = false
		r.ignorePrice = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.merchantProductRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIProductDeleteRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	merchantProductNo string
}

func (r ProductAPIProductDeleteRequest) Execute() (*ApiResponse, *http.Response, error) {
	return r.ApiService.ProductDeleteExecute(r)
}

/*
ProductDelete Deletes a product

Deletes a product based on the **Merchant product number**.<br /> <br />**NB:** ChannelEngine deactivates but does not delete the product entirely, as it might be still referenced in orders.<br />Therefore, the references used for this product cannot be reused.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param merchantProductNo The MerchantProductNo of the product you wish to delete.
 @return ProductAPIProductDeleteRequest
*/
func (a *ProductAPIService) ProductDelete(ctx context.Context, merchantProductNo string) ProductAPIProductDeleteRequest {
	return ProductAPIProductDeleteRequest{
		ApiService: a,
		ctx: ctx,
		merchantProductNo: merchantProductNo,
	}
}

// Execute executes the request
//  @return ApiResponse
func (a *ProductAPIService) ProductDeleteExecute(r ProductAPIProductDeleteRequest) (*ApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/products/{merchantProductNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"merchantProductNo"+"}", url.PathEscape(parameterValueToString(r.merchantProductNo, "merchantProductNo")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ApiResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIProductFreezeRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	freezeProductRequest *[]FreezeProductRequest
}

func (r ProductAPIProductFreezeRequest) FreezeProductRequest(freezeProductRequest []FreezeProductRequest) ProductAPIProductFreezeRequest {
	r.freezeProductRequest = &freezeProductRequest
	return r
}

func (r ProductAPIProductFreezeRequest) Execute() (*SingleOfApiResponse, *http.Response, error) {
	return r.ApiService.ProductFreezeExecute(r)
}

/*
ProductFreeze Updates selected products and sets them either to frozen or not-frozen status.

Changes state of products by updating it with FREEZE or UNFREEZE state.<br />All fields are required.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProductAPIProductFreezeRequest
*/
func (a *ProductAPIService) ProductFreeze(ctx context.Context) ProductAPIProductFreezeRequest {
	return ProductAPIProductFreezeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SingleOfApiResponse
func (a *ProductAPIService) ProductFreezeExecute(r ProductAPIProductFreezeRequest) (*SingleOfApiResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SingleOfApiResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductFreeze")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/products/freeze"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.freezeProductRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIProductGetByFilterRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	search *string
	eanList *[]string
	merchantProductNoList *[]string
	page *int32
}

// Search product(s) by Name, MerchantProductNo, Ean or Brand&lt;br /&gt;This search is applied to the result after applying the other filters.
func (r ProductAPIProductGetByFilterRequest) Search(search string) ProductAPIProductGetByFilterRequest {
	r.search = &search
	return r
}

// Search products by submitting a list of EAN&#39;s.
func (r ProductAPIProductGetByFilterRequest) EanList(eanList []string) ProductAPIProductGetByFilterRequest {
	r.eanList = &eanList
	return r
}

// Search products by submitting a list of MerchantProductNo&#39;s.
func (r ProductAPIProductGetByFilterRequest) MerchantProductNoList(merchantProductNoList []string) ProductAPIProductGetByFilterRequest {
	r.merchantProductNoList = &merchantProductNoList
	return r
}

// The page to filter on. Starts at 1.
func (r ProductAPIProductGetByFilterRequest) Page(page int32) ProductAPIProductGetByFilterRequest {
	r.page = &page
	return r
}

func (r ProductAPIProductGetByFilterRequest) Execute() (*CollectionOfMerchantProductResponse, *http.Response, error) {
	return r.ApiService.ProductGetByFilterExecute(r)
}

/*
ProductGetByFilter Gets products

Retrieve all products. Apply available filters to narrow down your search.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProductAPIProductGetByFilterRequest
*/
func (a *ProductAPIService) ProductGetByFilter(ctx context.Context) ProductAPIProductGetByFilterRequest {
	return ProductAPIProductGetByFilterRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CollectionOfMerchantProductResponse
func (a *ProductAPIService) ProductGetByFilterExecute(r ProductAPIProductGetByFilterRequest) (*CollectionOfMerchantProductResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CollectionOfMerchantProductResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductGetByFilter")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/products"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.eanList != nil {
		t := *r.eanList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "eanList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "eanList", t, "multi")
		}
	}
	if r.merchantProductNoList != nil {
		t := *r.merchantProductNoList
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "merchantProductNoList", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "merchantProductNoList", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIProductGetByMerchantProductNoRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	merchantProductNo string
}

func (r ProductAPIProductGetByMerchantProductNoRequest) Execute() (*SingleOfMerchantProductResponse, *http.Response, error) {
	return r.ApiService.ProductGetByMerchantProductNoExecute(r)
}

/*
ProductGetByMerchantProductNo Gets a product

Retrieves a product based on the **Merchant product number**.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param merchantProductNo The unique product reference used by the Merchant (sku).
 @return ProductAPIProductGetByMerchantProductNoRequest
*/
func (a *ProductAPIService) ProductGetByMerchantProductNo(ctx context.Context, merchantProductNo string) ProductAPIProductGetByMerchantProductNoRequest {
	return ProductAPIProductGetByMerchantProductNoRequest{
		ApiService: a,
		ctx: ctx,
		merchantProductNo: merchantProductNo,
	}
}

// Execute executes the request
//  @return SingleOfMerchantProductResponse
func (a *ProductAPIService) ProductGetByMerchantProductNoExecute(r ProductAPIProductGetByMerchantProductNoRequest) (*SingleOfMerchantProductResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SingleOfMerchantProductResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductGetByMerchantProductNo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/products/{merchantProductNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"merchantProductNo"+"}", url.PathEscape(parameterValueToString(r.merchantProductNo, "merchantProductNo")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v SingleOfMerchantProductResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIProductPatchRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	merchantProductNo string
	operation *[]Operation
}

// The JsonPatchDocument providing the operations you wish to perform on the product. &lt;br /&gt; Value contains the value you wish to set on the property you&#39;re updating (used with operations \&quot;add\&quot; and \&quot;replace\&quot;).&lt;br /&gt; Path contains the path to the property you&#39;re updating (e.g. Description). Every property in the model used for creation an updating can be used.&lt;br /&gt; Op contains the operation you wish to perform (\&quot;add\&quot;,\&quot;replace\&quot;,\&quot;remove\&quot;).&lt;br /&gt; From is only used when using the \&quot;move\&quot; operation. It refers to the source path of the value to be moved.
func (r ProductAPIProductPatchRequest) Operation(operation []Operation) ProductAPIProductPatchRequest {
	r.operation = &operation
	return r
}

func (r ProductAPIProductPatchRequest) Execute() (*SingleOfProductCreationResult, *http.Response, error) {
	return r.ApiService.ProductPatchExecute(r)
}

/*
ProductPatch Updates product attributes

Updates specific attributes of a single product based on the **Merchant product number**. The endpoint uses the [JSON Patch](http://jsonpatch.com/).<br /><br />Sample request:<br /><pre><br /> PATCH /v2/products/{merchantProductNo}<br /> {<br /> "value": "Value",<br /> "path": "Name",<br /> "op": "replace"<br /> }<br /></pre><br />Adding ExtraData:<br /><pre><br /> PATCH /v2/products/{merchantProductNo}<br /> {<br /> "value": {"key": "Key1", "value": "value1"},<br /> "path": "extraData/0",<br /> "op": "add"<br /> }<br /></pre><br />Replacing ExtraData (will replace entire ExtraData collection):<br /><pre><br /> PATCH /v2/products/{merchantProductNo}<br /> {<br /> "value": [{"key": "Key1", "value": "value1"}],<br /> "path": "extraData",<br /> "op": "replace"<br /> }<br /></pre><br />Removing all ExtraData:<br /><pre><br /> PATCH /v2/products/{merchantProductNo}<br /> {<br /> "path": "extraData",<br /> "op": "replace"<br /> }<br /></pre><br /> Or:<br /><pre><br /> PATCH /v2/products/{merchantProductNo}<br /> {<br /> "path": "extraData",<br /> "op": "remove"<br /> }<br /></pre>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param merchantProductNo The MerchantProductNo of the product you wish to patch
 @return ProductAPIProductPatchRequest
*/
func (a *ProductAPIService) ProductPatch(ctx context.Context, merchantProductNo string) ProductAPIProductPatchRequest {
	return ProductAPIProductPatchRequest{
		ApiService: a,
		ctx: ctx,
		merchantProductNo: merchantProductNo,
	}
}

// Execute executes the request
//  @return SingleOfProductCreationResult
func (a *ProductAPIService) ProductPatchExecute(r ProductAPIProductPatchRequest) (*SingleOfProductCreationResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SingleOfProductCreationResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductPatch")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/products/{merchantProductNo}"
	localVarPath = strings.Replace(localVarPath, "{"+"merchantProductNo"+"}", url.PathEscape(parameterValueToString(r.merchantProductNo, "merchantProductNo")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.operation
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ProductAPIProductPatchExtraDataItemsRequest struct {
	ctx context.Context
	ApiService *ProductAPIService
	merchantProductExtraDataRequest *MerchantProductExtraDataRequest
}

func (r ProductAPIProductPatchExtraDataItemsRequest) MerchantProductExtraDataRequest(merchantProductExtraDataRequest MerchantProductExtraDataRequest) ProductAPIProductPatchExtraDataItemsRequest {
	r.merchantProductExtraDataRequest = &merchantProductExtraDataRequest
	return r
}

func (r ProductAPIProductPatchExtraDataItemsRequest) Execute() (*SingleOfProductCreationResult, *http.Response, error) {
	return r.ApiService.ProductPatchExtraDataItemsExecute(r)
}

/*
ProductPatchExtraDataItems Adds, updates, or deletes a custom attribute

Adds, updates, or deletes the specific custom attribute (a.k.a. extra data key) for a single product.<br />You can update a single attribute for a product. The format of this endpoint is [JSON Patch](http://jsonpatch.com/).<br /><br />**NB:** the **Merchant product number** must be unique.<br /><br />Sample requests:<br /> <br />Adding ExtraData:<br /><pre><br /> PATCH /v2/products/extra-data<br /> {<br /> "MerchantProductNo": "{merchantProductNo}",<br /> "Operations": [<br /> {<br /> "Op": "add",<br /> "Key": "{Key}",<br /> "Value": "{Value}"<br /> }<br /> ]<br /> }<br /> </pre><br />Updating ExtraData:<br /><pre><br /> PATCH /v2/products/extra-data<br /> {<br /> "MerchantProductNo": "{merchantProductNo}",<br /> "Operations": [<br /> {<br /> "Op": "replace",<br /> "Key": "{Key}",<br /> "Value": "{Value}"<br /> }<br /> ]<br /> }<br /></pre><br />Removing ExtraData with key:<br /><pre><br /> PATCH /v2/products/extra-data<br /> {<br /> "MerchantProductNo": "{merchantProductNo}",<br /> "Operations": [<br /> {<br /> "Op": "remove",<br /> "Key": "{Key}",<br /> }<br /> ]<br /> }<br /></pre>

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ProductAPIProductPatchExtraDataItemsRequest
*/
func (a *ProductAPIService) ProductPatchExtraDataItems(ctx context.Context) ProductAPIProductPatchExtraDataItemsRequest {
	return ProductAPIProductPatchExtraDataItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SingleOfProductCreationResult
func (a *ProductAPIService) ProductPatchExtraDataItemsExecute(r ProductAPIProductPatchExtraDataItemsRequest) (*SingleOfProductCreationResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SingleOfProductCreationResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProductAPIService.ProductPatchExtraDataItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/products/extra-data"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json", "application/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.merchantProductExtraDataRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKey"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarQueryParams.Add("apikey", key)
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
